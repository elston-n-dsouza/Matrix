<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=MSSLfUayeNh9PW3ng9UWrqPqkO_clMDF6VDWdjQbdvNrveN7G_vBsknjfX404EGD_1W2z4Ggayje3DOqfHP14Q');.lst-kix_o7b80gr5ttpj-4>li{counter-increment:lst-ctn-kix_o7b80gr5ttpj-4}.lst-kix_6wd3a03erhcf-5>li{counter-increment:lst-ctn-kix_6wd3a03erhcf-5}ol.lst-kix_6wd3a03erhcf-6{list-style-type:none}ol.lst-kix_6wd3a03erhcf-5{list-style-type:none}ol.lst-kix_6wd3a03erhcf-8{list-style-type:none}ol.lst-kix_6wd3a03erhcf-7{list-style-type:none}ol.lst-kix_o7b80gr5ttpj-3.start{counter-reset:lst-ctn-kix_o7b80gr5ttpj-3 0}ol.lst-kix_6wd3a03erhcf-2{list-style-type:none}ol.lst-kix_6wd3a03erhcf-1{list-style-type:none}ol.lst-kix_6wd3a03erhcf-4{list-style-type:none}ol.lst-kix_6wd3a03erhcf-3{list-style-type:none}ol.lst-kix_6wd3a03erhcf-0{list-style-type:none}.lst-kix_22cqdvcubiwg-7>li{counter-increment:lst-ctn-kix_22cqdvcubiwg-7}.lst-kix_6wd3a03erhcf-4>li{counter-increment:lst-ctn-kix_6wd3a03erhcf-4}.lst-kix_22cqdvcubiwg-6>li{counter-increment:lst-ctn-kix_22cqdvcubiwg-6}ol.lst-kix_6wd3a03erhcf-2.start{counter-reset:lst-ctn-kix_6wd3a03erhcf-2 0}ol.lst-kix_6wd3a03erhcf-5.start{counter-reset:lst-ctn-kix_6wd3a03erhcf-5 0}ol.lst-kix_22cqdvcubiwg-5.start{counter-reset:lst-ctn-kix_22cqdvcubiwg-5 0}.lst-kix_o7b80gr5ttpj-5>li{counter-increment:lst-ctn-kix_o7b80gr5ttpj-5}ol.lst-kix_22cqdvcubiwg-8.start{counter-reset:lst-ctn-kix_22cqdvcubiwg-8 0}.lst-kix_o7b80gr5ttpj-2>li{counter-increment:lst-ctn-kix_o7b80gr5ttpj-2}ol.lst-kix_6wd3a03erhcf-8.start{counter-reset:lst-ctn-kix_6wd3a03erhcf-8 0}.lst-kix_o7b80gr5ttpj-7>li{counter-increment:lst-ctn-kix_o7b80gr5ttpj-7}.lst-kix_22cqdvcubiwg-6>li:before{content:"" counter(lst-ctn-kix_22cqdvcubiwg-6,decimal) ". "}.lst-kix_o7b80gr5ttpj-1>li{counter-increment:lst-ctn-kix_o7b80gr5ttpj-1}.lst-kix_22cqdvcubiwg-5>li:before{content:"" counter(lst-ctn-kix_22cqdvcubiwg-5,lower-roman) ". "}.lst-kix_22cqdvcubiwg-4>li:before{content:"" counter(lst-ctn-kix_22cqdvcubiwg-4,lower-latin) ". "}.lst-kix_22cqdvcubiwg-2>li:before{content:"" counter(lst-ctn-kix_22cqdvcubiwg-2,lower-roman) ". "}.lst-kix_22cqdvcubiwg-4>li{counter-increment:lst-ctn-kix_22cqdvcubiwg-4}ol.lst-kix_6wd3a03erhcf-1.start{counter-reset:lst-ctn-kix_6wd3a03erhcf-1 0}.lst-kix_22cqdvcubiwg-3>li:before{content:"" counter(lst-ctn-kix_22cqdvcubiwg-3,decimal) ". "}.lst-kix_22cqdvcubiwg-0>li:before{content:"" counter(lst-ctn-kix_22cqdvcubiwg-0,decimal) ". "}ol.lst-kix_o7b80gr5ttpj-5.start{counter-reset:lst-ctn-kix_o7b80gr5ttpj-5 0}.lst-kix_22cqdvcubiwg-1>li:before{content:"" counter(lst-ctn-kix_22cqdvcubiwg-1,lower-latin) ". "}ol.lst-kix_22cqdvcubiwg-2.start{counter-reset:lst-ctn-kix_22cqdvcubiwg-2 0}.lst-kix_22cqdvcubiwg-0>li{counter-increment:lst-ctn-kix_22cqdvcubiwg-0}.lst-kix_o7b80gr5ttpj-0>li:before{content:"" counter(lst-ctn-kix_o7b80gr5ttpj-0,decimal) ". "}ol.lst-kix_6wd3a03erhcf-7.start{counter-reset:lst-ctn-kix_6wd3a03erhcf-7 0}ol.lst-kix_6wd3a03erhcf-0.start{counter-reset:lst-ctn-kix_6wd3a03erhcf-0 0}.lst-kix_6wd3a03erhcf-6>li{counter-increment:lst-ctn-kix_6wd3a03erhcf-6}.lst-kix_6wd3a03erhcf-0>li{counter-increment:lst-ctn-kix_6wd3a03erhcf-0}ol.lst-kix_o7b80gr5ttpj-8{list-style-type:none}.lst-kix_6wd3a03erhcf-3>li{counter-increment:lst-ctn-kix_6wd3a03erhcf-3}ol.lst-kix_o7b80gr5ttpj-0.start{counter-reset:lst-ctn-kix_o7b80gr5ttpj-0 0}ol.lst-kix_o7b80gr5ttpj-7{list-style-type:none}ol.lst-kix_o7b80gr5ttpj-6{list-style-type:none}ol.lst-kix_o7b80gr5ttpj-5{list-style-type:none}ol.lst-kix_o7b80gr5ttpj-4{list-style-type:none}ol.lst-kix_22cqdvcubiwg-3.start{counter-reset:lst-ctn-kix_22cqdvcubiwg-3 0}ol.lst-kix_o7b80gr5ttpj-3{list-style-type:none}ol.lst-kix_o7b80gr5ttpj-2{list-style-type:none}ol.lst-kix_o7b80gr5ttpj-1{list-style-type:none}ol.lst-kix_o7b80gr5ttpj-0{list-style-type:none}ol.lst-kix_o7b80gr5ttpj-6.start{counter-reset:lst-ctn-kix_o7b80gr5ttpj-6 0}ol.lst-kix_6wd3a03erhcf-6.start{counter-reset:lst-ctn-kix_6wd3a03erhcf-6 0}ol.lst-kix_22cqdvcubiwg-1.start{counter-reset:lst-ctn-kix_22cqdvcubiwg-1 0}.lst-kix_22cqdvcubiwg-1>li{counter-increment:lst-ctn-kix_22cqdvcubiwg-1}ol.lst-kix_22cqdvcubiwg-0{list-style-type:none}ol.lst-kix_22cqdvcubiwg-1{list-style-type:none}ol.lst-kix_22cqdvcubiwg-2{list-style-type:none}ol.lst-kix_22cqdvcubiwg-4.start{counter-reset:lst-ctn-kix_22cqdvcubiwg-4 0}ol.lst-kix_22cqdvcubiwg-3{list-style-type:none}ol.lst-kix_22cqdvcubiwg-4{list-style-type:none}ol.lst-kix_22cqdvcubiwg-5{list-style-type:none}ol.lst-kix_22cqdvcubiwg-6{list-style-type:none}ol.lst-kix_o7b80gr5ttpj-7.start{counter-reset:lst-ctn-kix_o7b80gr5ttpj-7 0}ol.lst-kix_22cqdvcubiwg-7{list-style-type:none}ol.lst-kix_22cqdvcubiwg-8{list-style-type:none}ol.lst-kix_22cqdvcubiwg-7.start{counter-reset:lst-ctn-kix_22cqdvcubiwg-7 0}.lst-kix_o7b80gr5ttpj-1>li:before{content:"" counter(lst-ctn-kix_o7b80gr5ttpj-1,lower-latin) ". "}.lst-kix_o7b80gr5ttpj-2>li:before{content:"" counter(lst-ctn-kix_o7b80gr5ttpj-2,lower-roman) ". "}.lst-kix_22cqdvcubiwg-3>li{counter-increment:lst-ctn-kix_22cqdvcubiwg-3}ol.lst-kix_o7b80gr5ttpj-4.start{counter-reset:lst-ctn-kix_o7b80gr5ttpj-4 0}.lst-kix_o7b80gr5ttpj-5>li:before{content:"" counter(lst-ctn-kix_o7b80gr5ttpj-5,lower-roman) ". "}.lst-kix_o7b80gr5ttpj-8>li{counter-increment:lst-ctn-kix_o7b80gr5ttpj-8}.lst-kix_o7b80gr5ttpj-3>li:before{content:"" counter(lst-ctn-kix_o7b80gr5ttpj-3,decimal) ". "}.lst-kix_o7b80gr5ttpj-4>li:before{content:"" counter(lst-ctn-kix_o7b80gr5ttpj-4,lower-latin) ". "}ol.lst-kix_o7b80gr5ttpj-1.start{counter-reset:lst-ctn-kix_o7b80gr5ttpj-1 0}.lst-kix_o7b80gr5ttpj-6>li:before{content:"" counter(lst-ctn-kix_o7b80gr5ttpj-6,decimal) ". "}.lst-kix_o7b80gr5ttpj-7>li:before{content:"" counter(lst-ctn-kix_o7b80gr5ttpj-7,lower-latin) ". "}.lst-kix_o7b80gr5ttpj-8>li:before{content:"" counter(lst-ctn-kix_o7b80gr5ttpj-8,lower-roman) ". "}.lst-kix_22cqdvcubiwg-7>li:before{content:"" counter(lst-ctn-kix_22cqdvcubiwg-7,lower-latin) ". "}.lst-kix_6wd3a03erhcf-2>li{counter-increment:lst-ctn-kix_6wd3a03erhcf-2}.lst-kix_22cqdvcubiwg-8>li:before{content:"" counter(lst-ctn-kix_22cqdvcubiwg-8,lower-roman) ". "}ol.lst-kix_o7b80gr5ttpj-8.start{counter-reset:lst-ctn-kix_o7b80gr5ttpj-8 0}ol.lst-kix_22cqdvcubiwg-6.start{counter-reset:lst-ctn-kix_22cqdvcubiwg-6 0}.lst-kix_6wd3a03erhcf-8>li{counter-increment:lst-ctn-kix_6wd3a03erhcf-8}ol.lst-kix_6wd3a03erhcf-4.start{counter-reset:lst-ctn-kix_6wd3a03erhcf-4 0}.lst-kix_6wd3a03erhcf-1>li{counter-increment:lst-ctn-kix_6wd3a03erhcf-1}.lst-kix_6wd3a03erhcf-6>li:before{content:"" counter(lst-ctn-kix_6wd3a03erhcf-6,decimal) ". "}.lst-kix_6wd3a03erhcf-7>li:before{content:"" counter(lst-ctn-kix_6wd3a03erhcf-7,lower-latin) ". "}.lst-kix_6wd3a03erhcf-7>li{counter-increment:lst-ctn-kix_6wd3a03erhcf-7}.lst-kix_6wd3a03erhcf-8>li:before{content:"" counter(lst-ctn-kix_6wd3a03erhcf-8,lower-roman) ". "}ol.lst-kix_o7b80gr5ttpj-2.start{counter-reset:lst-ctn-kix_o7b80gr5ttpj-2 0}ol.lst-kix_22cqdvcubiwg-0.start{counter-reset:lst-ctn-kix_22cqdvcubiwg-0 0}.lst-kix_o7b80gr5ttpj-0>li{counter-increment:lst-ctn-kix_o7b80gr5ttpj-0}.lst-kix_o7b80gr5ttpj-3>li{counter-increment:lst-ctn-kix_o7b80gr5ttpj-3}.lst-kix_6wd3a03erhcf-5>li:before{content:"" counter(lst-ctn-kix_6wd3a03erhcf-5,lower-roman) ". "}.lst-kix_o7b80gr5ttpj-6>li{counter-increment:lst-ctn-kix_o7b80gr5ttpj-6}.lst-kix_6wd3a03erhcf-4>li:before{content:"" counter(lst-ctn-kix_6wd3a03erhcf-4,lower-latin) ". "}.lst-kix_6wd3a03erhcf-3>li:before{content:"" counter(lst-ctn-kix_6wd3a03erhcf-3,decimal) ". "}.lst-kix_6wd3a03erhcf-2>li:before{content:"" counter(lst-ctn-kix_6wd3a03erhcf-2,lower-roman) ". "}.lst-kix_22cqdvcubiwg-2>li{counter-increment:lst-ctn-kix_22cqdvcubiwg-2}ol.lst-kix_6wd3a03erhcf-3.start{counter-reset:lst-ctn-kix_6wd3a03erhcf-3 0}.lst-kix_22cqdvcubiwg-8>li{counter-increment:lst-ctn-kix_22cqdvcubiwg-8}.lst-kix_6wd3a03erhcf-1>li:before{content:"" counter(lst-ctn-kix_6wd3a03erhcf-1,lower-latin) ". "}.lst-kix_6wd3a03erhcf-0>li:before{content:"" counter(lst-ctn-kix_6wd3a03erhcf-0,decimal) ". "}.lst-kix_22cqdvcubiwg-5>li{counter-increment:lst-ctn-kix_22cqdvcubiwg-5}ol{margin:0;padding:0}table td,table th{padding:0}.c27{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:219pt;border-top-color:#000000;border-bottom-style:solid}.c10{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:98.2pt;border-top-color:#000000;border-bottom-style:solid}.c20{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:54.8pt;border-top-color:#000000;border-bottom-style:solid}.c25{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:291.8pt;border-top-color:#000000;border-bottom-style:solid}.c23{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:85.5pt;border-top-color:#000000;border-bottom-style:solid}.c7{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:138.4pt;border-top-color:#000000;border-bottom-style:solid}.c32{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:139.3pt;border-top-color:#000000;border-bottom-style:solid}.c18{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:212.2pt;border-top-color:#000000;border-bottom-style:solid}.c21{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:104.2pt;border-top-color:#000000;border-bottom-style:solid}.c12{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:57pt;border-top-color:#000000;border-bottom-style:solid}.c34{color:#808080;text-decoration:none;vertical-align:baseline;font-size:20pt;font-style:normal}.c33{color:#6d6c7a;text-decoration:none;vertical-align:baseline;font-size:26pt;font-style:normal}.c28{color:#548dd4;text-decoration:none;vertical-align:baseline;font-size:10pt;font-style:normal}.c15{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c24{color:#365f91;text-decoration:none;vertical-align:baseline;font-size:16pt;font-style:normal}.c30{color:#808080;text-decoration:none;vertical-align:baseline;font-size:28pt;font-style:normal}.c8{color:#808080;text-decoration:none;vertical-align:baseline;font-size:12pt;font-style:normal}.c5{color:#000000;text-decoration:none;vertical-align:baseline;font-size:12pt;font-style:normal}.c13{padding-top:12pt;padding-bottom:0pt;line-height:1.0791666666666666;page-break-after:avoid;text-align:left}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c16{border-spacing:0;border-collapse:collapse;margin-right:auto}.c26{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:center}.c14{background-color:#ffffff;max-width:415.3pt;padding:72pt 90pt 72pt 90pt}.c2{margin-left:36pt;padding-left:0pt}.c11{padding-bottom:5pt;line-height:1.0791666666666666}.c0{font-weight:400;font-family:"Dosis"}.c29{font-size:10pt;color:#548dd4}.c22{padding:0;margin:0}.c35{font-weight:400;font-family:"Cambria"}.c1{orphans:2;widows:2}.c31{padding-top:0pt;text-align:left}.c19{font-weight:700;font-family:"Dosis"}.c3{height:12pt}.c6{height:0pt}.c9{margin-left:10.8pt}.c17{font-size:11pt}.title{padding-top:12pt;color:#000000;font-size:14pt;padding-bottom:6pt;font-family:"Verdana";line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:12pt;color:#000000;font-size:14pt;padding-bottom:6pt;font-family:"Verdana";line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:12pt;font-family:"Cambria"}p{margin:0;color:#000000;font-size:12pt;font-family:"Cambria"}h1{padding-top:12pt;color:#365f91;font-size:16pt;padding-bottom:0pt;font-family:"Calibri";line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:12pt;color:#000000;font-size:14pt;padding-bottom:6pt;font-family:"Verdana";line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:12pt;color:#000000;font-size:14pt;padding-bottom:6pt;font-family:"Verdana";line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:3pt;font-family:"Cambria";line-height:1.0;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#000000;font-weight:700;font-size:13pt;padding-bottom:3pt;font-family:"Cambria";line-height:1.0;font-style:italic;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:3pt;font-family:"Cambria";line-height:1.0;orphans:2;widows:2;text-align:left}</style></head><body class="c14"><p class="c4 c1 c3"><span class="c29 c19"></span></p><p class="c4 c1 c3"><span class="c19 c29"></span></p><p class="c4 c1 c3"><span class="c29 c19"></span></p><p class="c4 c1"><span class="c28 c19">ADNOC Schools of Abu Dhabi &ndash; Ruwais Campus</span></p><p class="c1 c3"><span class="c28 c19"></span></p><p class="c1 c3"><span class="c19 c28"></span></p><p class="c1 c3"><span class="c28 c19"></span></p><p class="c1 c3"><span class="c28 c19"></span></p><p class="c26 c1"><span class="c19 c33">Implementing Java in Mathematics and Engineering</span></p><p class="c26 c1"><span class="c0 c30">Beyond &ldquo;Hello World!&rdquo;</span></p><p class="c26 c1"><span class="c0 c34">Elston Neil D&#39;Souza</span></p><p class="c26 c1 c3"><span class="c34 c0"></span></p><p class="c26 c1"><span class="c0 c8">Grade 12</span></p><p class="c1 c26"><span class="c8 c0">AP Computer Science</span></p><p class="c26 c1 c3"><span class="c8 c0"></span></p><p class="c26 c1"><span class="c8 c0">Nassim Boubekri</span></p><hr style="page-break-before:always;display:none;"><p class="c1 c13"><span class="c0 c24">Table of Contents</span></p><p class="c11 c1 c31"><span class="c15 c19">Matrices</span><span class="c15 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c19 c17">3</span></p><p class="c11 c1 c9"><span class="c0 c17">Introduction to Matrix Terminology 3</span></p><p class="c1 c9 c11"><span class="c0 c17">Solving an n&times;n Matrix using Cramer&#39;s Method 3</span></p><p class="c11 c1 c9"><span class="c0 c17">Matrix Multiplication 9</span></p><p class="c11 c1 c31 c9"><span class="c15 c0">Solving an n&times;n Matrix using Gauss Jordan Method </span><span class="c0 c17">10</span></p><p class="c11 c1 c9 c31"><span class="c15 c0">Finding the inverse of an Matrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span><span class="c0 c17">6</span></p><p class="c11 c1 c31"><span class="c15 c19">Integration</span><span class="c15 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c19 c17">21</span></p><p class="c11 c1 c31 c9"><span class="c15 c0">Integration </span><span class="c0 c17">21</span></p><p class="c1 c9"><span class="c0">Sample Functions and their Tests </span><span class="c0">25</span></p><p class="c1 c3 c9"><span class="c0"></span></p><p class="c1 c9"><span class="c0">Analysis of Epsilon 27</span></p><p class="c1 c3 c9"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Solving a n by n matrix using </span><span class="c0">Cramer&#39;s </span><span class="c0">method and Gauss Jordan</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">A matrix is a set of numbers arranged in rows and column. These numbers have various significance when all used together. They may have special meaning, for example, a matrix could be defined as a particular vector in 3D space. Matrices have had a big impact in the world of science and the world of applied sciences. </span></p><p class="c1"><span class="c0">As previously discussed, matrices are of particular importance in our lives. But it is just as important to know the terminology and the methods and functions that apply to them. </span></p><p class="c1"><span class="c0">The aim of this computing task is to create an abstraction in which information may be extracted from a n by n matrix. </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c19">Terminology </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Determinant </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">A determinant in layman&rsquo;s terms can be considered in many instances the magnitude of the matrix. Suppose a certain matrix defines a velocity vector, </span><img src="images/image00.png"><span class="c0">, then the determinant of the matrix can be considered to be the magnitude of the velocity vector ala the speed of the object. There are various different ways to calculate the determinant of a matrix. </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">For simplicities sake, the determinant of the following 2 by 2 matrix can be found by subtracting the product of the diagonals. </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 356.00px; height: 136.00px;"><img alt="determinant.gif" src="images/image05.gif" style="width: 356.00px; height: 136.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Inverse </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">The inverse is a matrix that is constructed from the original matrix. One inverse and its corresponding matrix multiplied together will give the identity matrix which is a certain matrix where the diagonal is 1 and the rest of the values are 0.</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">An example of a identity matrix is shown below</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.70px; height: 310.67px;"><img alt="identity2.gif" src="images/image07.gif" style="width: 553.70px; height: 310.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">The inverse doesn&rsquo;t exist if a determinant is equal to zero. </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Solutions of matrices</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">The importance of matrices in this specific context is to solve equations. These equations are linear equations and have n terms in them. In order to find, n unknowns, one would require n sets of equations. The coefficients in these system of equations can represent a matrix. Of length n and width n. </span></p><p class="c1"><span class="c0">Cofactor </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Minors</span></p><p class="c1"><span class="c0">A minor matrix is a matrix that of equal size (n by n). &nbsp;Suppose element s in on row r and column c, then the matrix of minors can be constructed by finding the determinant of a matrix that is not on row r and column c. The value of the determinant will be placed in element s&rsquo;s location on the original matrix.</span></p><p class="c1"><span class="c0">This process is better illustrated with the visual example below. </span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 273.00px; height: 353.00px;"><img alt="matrix-minors1.gif" src="images/image06.gif" style="width: 273.00px; height: 353.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Adjugate Matrix</span></p><p class="c1"><span class="c0">This process takes an old matrix and switches the row and the column so that the matrix is flipped across diagonally. &nbsp;</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c19">Processes</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">One may employ various methods in order to evaluate the solution for the nth term. </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">The two implemented today are the Gauss Jordan Approach and the Cramer approach..</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Gauss Jordan </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Algorithm </span></p><ol class="c22 lst-kix_o7b80gr5ttpj-0 start" start="1"><li class="c1 c2"><span class="c0">Create a matrix of n rows and 2n + 1 columns. </span></li><li class="c2 c1"><span class="c0">The columns from col = 0 &nbsp;to col = n-1 will be occupied by the coefficients of the equation. </span></li><li class="c2 c1"><span class="c0">On the nth column, input the numerical values for the equations. </span></li><li class="c2 c1"><span class="c0">The last segment will be occupied by a identity matrix of size n by n. </span></li><li class="c2 c1"><span class="c0">Begin a loop where the matrix is normalized.</span></li><li class="c2 c1"><span class="c0">Begin subtraction. </span></li><li class="c2 c1"><span class="c0">Repeat 5 and 6 until the identity matrix is achieved in the left-most matrix. </span></li><li class="c2 c1"><span class="c0">You may find the nth term of the system of equations and finding the corresponding solution. This is because all the others in the row are zero meaning that the value of the nth x term will be the one in the solution column. </span></li></ol><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Using the Cramer&rsquo;s Rule </span></p><p class="c1"><span class="c0">The Cramer&rsquo;s Rule is a method for finding the solution of the nth term in a system of linear equations with n unknowns and n equations. Create a matrix that stores the coefficients of each unknown term within the 2D array, try using double values to take into account any decimal and non integers and for greater precision. The solutions array is the array of double values that corresponds to the system of linear equations. </span></p><ol class="c22 lst-kix_6wd3a03erhcf-0 start" start="1"><li class="c2 c1"><span class="c0">Create a new matrix that is similar to the original matrix in every way except that the nth column is replaced with the solutions array.</span></li><li class="c2 c1"><span class="c0">Divide the determinant of the new array by the determinant of the original array to find the solution of the nth term.</span></li></ol><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c19">Architecture of the Matrix Solver Class </span></p><p class="c1"><span class="c0">For this implementation, a java class known as MatrixSolver was written. The MatrixSolver class features multiple public methods that provide functionality to another class. The private methods are helper methods that exist to reduce the complexity of the task and to break down the problem into manageable chunks.</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><a id="t.04776c5084675bb38021250cc13715f080c5cc09"></a><a id="t.0"></a><table class="c16"><tbody><tr class="c6"><td class="c12" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Method</span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Arguments</span></p></td><td class="c32" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Purpose</span></p></td></tr><tr class="c6"><td class="c12" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c0">getIt()</span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c19">double[][] matrix, double[] equals, int xcol</span></p><p class="c4 c1"><span class="c5 c0">Matrix - is a two dimensional array consisting of double values. This 2D array represents a system of linear equations. It is assumed that this matrix is of size &nbsp;n by n</span></p><p class="c4 c1"><span class="c5 c0">Equals - is a one dimensional array that is the result of the system of equations that corresponds to the row of the matrix given as the first argument. It is &nbsp;assumed that this array is of size n because the rows of the matrix are of size n.</span></p><p class="c4 c1"><span class="c5 c0">Xcol is the integer representing the x term that the function needs to find. </span></p></td><td class="c32" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">This public method solves the matrix (system of linear equations ) and finds the value of the nth term of the coefficients of the equations presented in the matrix. &nbsp;It does this using the Cramer&rsquo;s rule. Returns a double</span></p></td></tr><tr class="c6"><td class="c12" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c0">getDet()</span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c19">double[][] mat, int cols</span></p><p class="c4 c1"><span class="c5 c0">Mat - a two dimensional matrix of size n by n filled with values of doubles.</span></p><p class="c4 c1"><span class="c5 c0">Cols - a integer representing the width of the matrix</span></p><p class="c4 c1 c3"><span class="c5 c0"></span></p></td><td class="c32" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">This is also a public method that can be used to find the determinant of a certain matrix. The way this is done is by taking a matrix and running the getSmaller method, A smaller and smaller matrix is used until the size of the n by n matrix is 2 by 2, then the determinant can be found easily (the difference between the product of the diagonals).</span></p></td></tr><tr class="c6"><td class="c12" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">getSmaller() </span></p></td><td class="c27" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c19">double [][] mat, int cols</span></p><p class="c4 c1 c3"><span class="c5 c0"></span></p></td><td class="c32" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">This is a private method that is only accessible by members of the class. The function getSmaller() will get a matrix that is n-1 by n-1 &nbsp;from a n by n matrix and this matrix will not include any element on the 1st row and the column specified by the cols variable.</span></p></td></tr></tbody></table><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">class MatrixSolver{</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; public &nbsp; double getIt(double[][] matrix, double[] equals, int xcol) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp;double [][] oldMat = matrix;</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double ins = &nbsp;(getDet(matrix, matrix[0].length));</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp;double [][] newermat = replace(oldMat, equals, xcol);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp;double division = getDet(newermat, matrix[0].length) / ins;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; return division;</span></p><p class="c1"><span class="c0">&nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; private &nbsp;double[][] replace(double[][] matriesx, double[] vas, int sol) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; double [][] newtempMat = matriesx;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; for (int i = 0; i &lt; newtempMat.length; i++) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; newtempMat[i][sol] = vas[i];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; return newtempMat;</span></p><p class="c1"><span class="c0">&nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; </span><span class="c0">Public </span><span class="c0">&nbsp;double getDet(double[][] mat, int cols) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; if (cols == 2) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; double doubledet =mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; return doubledet;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; } else {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; double finalesum = 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int iterator = cols;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (iterator &gt; 0){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finalesum +=(double) -mat[0][iterator - 1]* Math.pow(-1, iterator ) &nbsp;* getDet(getSmaller(mat, iterator), cols - 1) ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterator--;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; return finalesum;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp;private &nbsp;double [][] getSmaller (double [][] mat, int cols){</span></p><p class="c1"><span class="c0">&nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; cols = cols-1;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double [][] matrixer = new double [mat.length-1][mat[0].length-1];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //Integers for integers for iterating over the new matrixer</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int r = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int c = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int rower = 1 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int colomer = 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; while (r&lt; matrixer.length){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (c &lt; matrixer[0].length){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (colomer != cols){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matrixer [r][c] = mat[rower][colomer];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colomer ++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">//Reset column and increment row</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c= 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colomer = 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rower++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">}</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return matrixer; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Multiplication of a n by n matrix</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">class MatrixMultiplier{</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; public static double [][] getmultiple(double[][] m1, double[][] m2){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int sums = 0;</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double [][] product = new double [m1.length][m2[0].length];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int k = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0 ; i &lt; m1.length ; i ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int b = 0; b &lt; m2[0].length; b++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (k &lt; m2[0].length){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sums += m1[i][k]* m2 [k] [b];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;product[i][b] = sums;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k= 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sums =0;</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return product;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">//Printing a 2D matrix</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public static void printIt(int [][] a){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0 ; i &lt; a.length ; i ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int b = 0 ; b &lt; a[0].length ; b ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(a[i][b]+ &quot; &quot;);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println();</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Solving using Gauss Jordan Method</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">After the function solve () is called, the Gauss Jordan returns the identity matrix, the solutions and the inverse. The </span><span class="c0">determinant </span><span class="c0">can also be found using this method.</span></p><p class="c1"><span class="c0">This method of solving matrixes can is preferred because it does multiple tasks at once. It features the least implementation compared to other methods. </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c19">Architecture of the GaussJordan class</span></p><p class="c1"><span class="c0">The GaussJordan class was implemented by manipulating a big matrix that is composed of smaller segments. The user passes a matrix and a solution to the system of equations via the constructor. A new matrix is created that is length n and width 2n+1 which includes a matrix of identity and the solution array.</span></p><p class="c1"><span class="c0">The subtract and normalize methods are applied to the big matrix and the process is done for a total of n times which is until the identity matrix forms on the location of the original matrix. The location where the identity matrix used to be is now the inverse. The nth solution can be easily found by accessing the nth row of the column that used to previously store the solutions for the system of &nbsp;equations.</span></p><p class="c1 c3"><span class="c19"></span></p><p class="c1"><span class="c19">Variables </span></p><p class="c1 c3"><span class="c19"></span></p><a id="t.c0f44c414def57bc63d04d3146fb2593483d32e8"></a><a id="t.1"></a><table class="c16"><tbody><tr class="c6"><td class="c23" colspan="1" rowspan="1"><p class="c4"><span class="c5 c19">Name </span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c4"><span class="c5 c19">Data Type</span></p></td><td class="c25" colspan="1" rowspan="1"><p class="c4"><span class="c5 c19">Purpose</span></p></td></tr><tr class="c6"><td class="c23" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">length</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">int</span></p></td><td class="c25" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Length of the matrix</span></p></td></tr><tr class="c6"><td class="c23" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">width</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">int</span></p></td><td class="c25" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">The size of the matrix with the identity matrix and the solution (2n + 1 )</span></p></td></tr><tr class="c6"><td class="c23" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">realArrWidth</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">int</span></p></td><td class="c25" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">The width of the matrix that was inputed (size n)</span></p></td></tr><tr class="c6"><td class="c23" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Determinant </span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">double</span></p></td><td class="c25" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">The determinant of the matrix (initialized to 1)</span></p></td></tr><tr class="c6"><td class="c23" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">matrix</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Double [][]</span></p></td><td class="c25" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">The complete matrix with size n by 2n+1. This matrix includes the original matrix, the solutions and the identity matrix.</span></p></td></tr></tbody></table><p class="c1 c3"><span class="c19"></span></p><p class="c1 c3"><span class="c19"></span></p><p class="c1 c3"><span class="c19"></span></p><p class="c1 c3"><span class="c19"></span></p><p class="c1 c3"><span class="c19"></span></p><p class="c1 c3"><span class="c19"></span></p><p class="c1 c3"><span class="c19"></span></p><p class="c1 c3"><span class="c19"></span></p><p class="c1 c3"><span class="c19"></span></p><p class="c1 c3"><span class="c19"></span></p><p class="c1 c3"><span class="c19"></span></p><p class="c1"><span class="c19">Methods </span></p><p class="c1 c3"><span class="c19"></span></p><p class="c1 c3"><span class="c19"></span></p><a id="t.a991767b55bca2e2c7d490138413e1c64d6ce7ab"></a><a id="t.2"></a><table class="c16"><tbody><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c4"><span class="c5 c19">Name </span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c4"><span class="c5 c19">Access</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c5 c19">Purpose</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c0">InsertMatrix </span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Inserts the input matrix to the big matrix that is in this.matrix. The columns 0 to n-1 are occupied as a result of this method.</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c4 c1"><span class="c0 c5">InsertSolutions </span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Inserts the array of the solutions of the system of equations into the big this.matrix. The nth column is filled by the method</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c0">InsertIdentityMatrix </span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Inserts an 2D &nbsp;array into the column from n+1 to 2n. This identity matrix is of the same size as the array passed into the class.</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c0">getDeterminant </span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">public</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Returns the determinant of the original matrix. </span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c0">solve </span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Called at the end of the constructor. It begins the process of subtracting and normalizing the matrix.</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c0">subtract </span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Subtracts every element in the matrix by the corresponding element with the same column but with the row specified by the parameter.</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c0">normalize</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Divides every element in each column by the element specified by the parameters.</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c0">finalnormalize</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">The final normalize that normalizes the diagonals so that the identity matrix is formed on the left hand side.</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c0">getSolution</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">public</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Returns the solution of the term specified by the parameters</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c0">getInverse</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">public</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Returns a n by n matrix that is the matrix from n+1 to 2n of the big matrix.</span></p></td></tr></tbody></table><p class="c1 c3"><span class="c19"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">public class GaussJordan{</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Width and length of the entire big array</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private int length;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private int width;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private int realArrWidth;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double determinant;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double [][] matrix;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public GaussJordan (double[][] givenMatrix, double [] solutions){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.realArrWidth = givenMatrix[0].length;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.length = givenMatrix.length;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.width = (2*realArrWidth) +1;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.matrix = new double [length][width];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.determinant = 1;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Create the matrix</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; InsertMatrix(givenMatrix);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; InsertSolutions(solutions);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; InsertIdentityMatrix();</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; solve();</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private void InsertMatrix (double [][] givenMatrix ){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; for (int i &nbsp;= 0 ; i &lt; realArrWidth; i ++ ){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int k = &nbsp;0 ; k &lt; length ; k ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.matrix[i][k] = givenMatrix [i][k];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Insert solutions to this matrix</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private void InsertSolutions (double [] solutions){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0 ; i &lt; length ; i++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.matrix [i][realArrWidth] = solutions [i];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Inserts the identity matrix</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private void InsertIdentityMatrix (){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int r = 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int c = realArrWidth +1;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; while (c &lt; width &amp;&amp; r &lt; length &nbsp;){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.matrix [r][c] = 1;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Returns the Matrix....</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Currently used for printing purposes</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public double [][] getMatrix (){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return matrix;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Returns the xth solution of the system of equations</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double getSolution (int xth){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return matrix[xth][realArrWidth]; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Returns the 2D array from col &gt; realArrWidth</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; That was initially the identity matrix</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public double [][] getInverse (){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //The inverse &nbsp;matrix</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double [][] inverseMatrix = &nbsp;new double [realArrWidth][realArrWidth];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //Loop through and fill the inverse matrix</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int Iiterator = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; for (int i &nbsp;= realArrWidth+1; i &lt; width ; i ++ ){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int k = &nbsp;0 ; k &lt; length ; k ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inverseMatrix [k][Iiterator] = matrix [k][i];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Iiterator++;</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return inverseMatrix;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double getDeterminant (){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return determinant;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Normalize the matrix.</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Gets the</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double [][] normalize (double [][] TempMatrix , int col ){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;for (int i = 0 ; i &lt; TempMatrix.length ; i ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;double valueToDivideBy = TempMatrix[i][col];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for ( int k = 0 ; k &lt; TempMatrix[0].length ; k++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TempMatrix [i][k] /= valueToDivideBy; //Divides every row with the value specified</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;determinant *= valueToDivideBy; //Updates the Determinant</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;return TempMatrix;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public double [][] subtract (double [][] TempMatrix , int rowSub){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; Keeps the row constant and iterated through the column</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;int row = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;int col = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;while (row &lt; TempMatrix.length ){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (row != rowSub){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while (col &lt; TempMatrix[0].length){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TempMatrix[row][col] = TempMatrix [row][col] - TempMatrix [rowSub][col]; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col ++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col = 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; row ++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;return TempMatrix;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Normalizes and Subtractes the matrix at every iteration for n number of iterations</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span><span class="c0">Private </span><span class="c0">void solve (){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0 ; i &nbsp;&lt; &nbsp;this.length ;i ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; normalize (this.matrix, i);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtract(this.matrix, i);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; finalNormalize (this.matrix);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; This is the final normalize method to reduce everything to the identity matrix</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public void finalNormalize ( double [][] matrix ){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int traverser = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double valueToDivide = 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; while (traverser &lt; length){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valueToDivide = matrix &nbsp;[traverser][traverser];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0 ; i &lt; width ; i ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matrix[traverser][i] /= valueToDivide;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; traverser++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Find the inverse of the matrix</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Process </span></p><ol class="c22 lst-kix_22cqdvcubiwg-0 start" start="1"><li class="c2 c1"><span class="c0">Get the matrix of minors. </span></li><li class="c2 c1"><span class="c0">Get the matrix of cofactors </span></li><li class="c2 c1"><span class="c0">Get the adjoint matrix.</span></li><li class="c2 c1"><span class="c0">Multiply the determinant with the adjoint matrix like a scalar multiple to return the inverse.</span></li></ol><p class="c1"><span class="c0">Methods</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><a id="t.86316441fe11468597ce04537500fcd9fdef8cb3"></a><a id="t.3"></a><table class="c16"><tbody><tr class="c6"><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Method Name</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Access</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Purpose</span></p></td></tr><tr class="c6"><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">getDet</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Get the determinant of a matrix. Calls getSmaller until 2 by 2 matrix is formed.</span></p></td></tr><tr class="c6"><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">printIt</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">public</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Testing print method for a 2D array of doubles</span></p></td></tr><tr class="c6"><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">getSmaller </span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">A smaller matrix that is used in the calculation of determinant</span></p></td></tr><tr class="c6"><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">getMatrixOfMinors</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Returns the matrix of minors</span></p></td></tr><tr class="c6"><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">getMatrixOfCofactors</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Returns the matrix of cofactors</span></p></td></tr><tr class="c6"><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">getAdjoint</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Returns a matrix that is flipped across the diagonals.</span></p></td></tr><tr class="c6"><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">getInverse</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">public</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Only public method that glues together the algorithm.</span></p></td></tr><tr class="c6"><td class="c7" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c0">getMatrixThatisNotIt</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Returns a matrix that is 1 element shorter and thinner. Any element &nbsp;row,i, and the col, z, are excluded.</span></p></td></tr><tr class="c6"><td class="c7" colspan="1" rowspan="1"><p class="c4 c1"><span class="c5 c0">scalarMultiple</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">private</span></p></td><td class="c7" colspan="1" rowspan="1"><p class="c4"><span class="c5 c0">Multiplies the determinant to the adjoint matrix.</span></p></td></tr></tbody></table><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">class MatrixInverser {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private &nbsp;double getDet(double[][] mat, int cols) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; if (cols == 2) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; double doubledet =mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; return doubledet;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; } else {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; double finalesum = 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int iterator = cols;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (iterator &gt; 0){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finalesum +=(double) -mat[0][iterator - 1]* Math.pow(-1, iterator ) &nbsp;* getDet(getSmaller(mat, iterator), cols - 1) ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iterator--;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; return finalesum;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;//Simple printing method for a 2D matrix</span></p><p class="c1"><span class="c0">&nbsp; </span><span class="c0">public</span><span class="c0">&nbsp;void printIt(double[][] a) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; for (int i = 0; i &lt; a.length; i++) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; for (int b = 0; b &lt; a[0].length; b++) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; System.out.print(a[i][b] + &quot; &quot;);</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; System.out.println();</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; System.out.println();</span></p><p class="c1"><span class="c0">&nbsp; }</span></p><p class="c1"><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp;/*</span></p><p class="c1"><span class="c0">&nbsp; This function will get a smaller sub matrix of the mat matrix as specified &nbsp;by the cols variable</span></p><p class="c1"><span class="c0">&nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp;private &nbsp;double [][] getSmaller (double [][] mat, int cols){</span></p><p class="c1"><span class="c0">&nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; cols = cols-1;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double [][] matrixer = new double [mat.length-1][mat[0].length-1];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //Integers for integers for iterating over the new matrixer</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int r = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int c = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int rower = 1 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int colomer = 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //Integers for iterating over</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; while (r&lt; matrixer.length){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (c &lt; matrixer[0].length){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (colomer != cols){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matrixer [r][c] = mat[rower][colomer];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c++;</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colomer ++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c= 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colomer = 0;</span></p><p class="c1"><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rower++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return matrixer; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public &nbsp;double [][] getInverse (double [][] matrix){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double [][] minors = getMatrixOfMinors(matrix);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double [][] cofactors = getMatrixOfCofactors(minors);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double [][] adjoint = getAdjoint(cofactors);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double determinant = getDet(matrix, matrix.length) ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return scalarMultiple (adjoint, 1/determinant);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private &nbsp;double [][] getMatrixOfMinors (double[][] matrix){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double[][] tempMat = matrix;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double [][] matOfminors = &nbsp;new double [matrix.length][matrix.length];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0 ; i &lt; tempMat.length ; i ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int z= 0 ; z &lt; tempMat.length ; z ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matOfminors[i][z]=getDet(getMatrixThatisNotIt(tempMat,i,z),matrix.length-1);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return matOfminors;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private &nbsp;double[][] scalarMultiple (double [][] array , double factor){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 0 ; i &lt; array.length ; i ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int z= 0 ; z &lt; array[0].length ; z ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;array [i][z] = factor * array[i][z];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return array;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Create a sub matrix that is one unit smaller than the original matrix.</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; This matrix doesn&#39;t includes all the elements in the matrix that are on the same row or colomn</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; as a certain pivot element.</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; That pivot element is defined by int i and int z</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private &nbsp;double [][]getMatrixThatisNotIt(double[][] matrix, int i , int z ){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double [][] smallerMatrix = new double [matrix.length-1][matrix[0].length-1];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int r = 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int c = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ///Bigger iterator</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int rowI = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int colI = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; while (r &lt; smallerMatrix.length){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (rowI != i){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (c &lt; smallerMatrix[0].length){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (colI != z){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; smallerMatrix [r][c] = matrix[rowI][colI];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colI++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;r++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colI = 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowI++;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return smallerMatrix;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Returns a new matrix that fits the criteria of the matrix of cofactors......every alternating</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; row and column has been negated</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private &nbsp;double [][] getMatrixOfCofactors (double [][]matrix ){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; double constant = 1;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; for (int i = 0 ; i &nbsp;&lt; matrix.length &nbsp;; i ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int z = 0 ; z &lt; matrix[0].length ; z ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matrix[i][z] = constant * matrix[i][z];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constant = -constant;//Negate the constant</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; return matrix;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; /*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Returns a new matrix which is the the cofactor with all its rows flipped with its column</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private &nbsp;double [][] getAdjoint (double [][] matrix){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //Recieves the cofactor matrix and transforms it into the Adjoin by transposing the matrix</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //Flips the matrix ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double [][] newMats = new double [matrix.length][matrix[0].length];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int cols = 0 ; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0 ; i &lt; matrix.length ; i ++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;double [] storArr = matrix[i];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int p = 0 ; p &lt; newMats.length ; p++){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;newMats[p][cols]= storArr [p];</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cols++;</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return newMats;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Integration</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">The aim of integration is to find the summation of all infinitesimal portions (&ldquo;chunks&rdquo;) of area underneath a curve.</span></p><p class="c1"><span class="c0">The methods of integration that are employed in this implementation is a direct application of the methods used by Riemann approximations.</span></p><p class="c1"><span class="c0">Riemann approximation illustrate that &nbsp;the area under a curve can be found by using the equation of the area of a rectangle, however in this case the width of the rectangles can be made arbitrarily small which increases the accuracy of the approximation. </span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 479.00px; height: 21.00px;"><img alt="\Delta x \left[f(a) + f(a + \Delta x) + f(a + 2 \Delta x)+\cdots+f(b - \Delta x)\right]." src="images/image04.png" style="width: 479.00px; height: 21.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">This is true because the amount of excess accumulation and (insufficient accumulation) in some cases cause the true value of the integral to lie between an uncertainty, the lower the width of each individual rectangle, the close to the correct value we are and the lesser the certainty.</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Importance of Integration </span></p><p class="c1"><span class="c0">Integration allows us to calculate values in &nbsp;relationships that weren&rsquo;t possible before. Now the theories of Integration enable us to calculate net accumulations, Although the previous statement may be vague, the real purpose of integral exceeds the scope of this discussion. Integration enables us to calculate changes, suppose variable f is the derivative of variable g with respect to time. Then the changes in f can be found by integrating g with the necessary limits. </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">In a real life context, suppose rate of production varies with time then by integrating the rate of production the number of products produced can be calculated. &nbsp;The same can be done for velocity, acceleration, voltages, currents, power, forces, electromagnetic fields, energies, rates of reactions. </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">There are three example function whose areas and implementation are featured below.</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">The calculation of all approximations of integrals features one parameter, n which is the number of segments to be taken into consideration. The greater the number of segments, the greater the accuracy from the true value of the definite integral.</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">As n become sufficiently large, epsilon become infinitesimally small and the limit of epsilon reaches 0, which indicates a perfect answer.</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">For all purposes, the value of n need not reach infinite. It need to be only quite large to get a correct value and excessively high values of n will waste time and computation power.</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Architecture of Function </span></p><p class="c1"><span class="c0">The abstract class Function features various implementation of methods of approximation of the area below the curve.</span></p><p class="c1"><span class="c0">The Function class features an abstract method f() which forces all inheriting class to implement their own version of the function.</span></p><p class="c1"><span class="c0">There are also various to methods to show the relative difference in the definite integral aka epsilon.</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Types of Sums </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Right Hand </span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 366.00px; height: 21.00px;"><img alt="\Delta x \left[ f( a + \Delta x ) + f(a + 2 \Delta x)+\cdots+f(b) \right]." src="images/image12.png" style="width: 366.00px; height: 21.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">Left Hand</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 479.00px; height: 21.00px;"><img alt="\Delta x \left[f(a) + f(a + \Delta x) + f(a + 2 \Delta x)+\cdots+f(b - \Delta x)\right]." src="images/image04.png" style="width: 479.00px; height: 21.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">Midpoint </span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 410.00px; height: 24.00px;"><img alt="\Delta x\left[f(a + \tfrac{\Delta x}{2}) + f(a + \tfrac{3\Delta x}{2})+\cdots+f(b-\tfrac{\Delta x}{2})\right]." src="images/image13.png" style="width: 410.00px; height: 24.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">Trapezoid </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 553.70px; height: 21.33px;"><img alt="\tfrac{1}{2}\Delta x\left[f(a) + 2f(a+\Delta x) + 2f(a+2\Delta x) + 2f(a+3\Delta x)+\cdots+f(b)\right]." src="images/image03.png" style="width: 553.70px; height: 21.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">abstract class Function {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; //Limits of integration</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double a ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double b ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Function (){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //Empty Constructor</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Function (int a, int b){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.a = a;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.b = b;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public double getA() {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return a;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public void setA(double a) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.a = a;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public double getB() {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return b;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public void setB(double b) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; this.b = b;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp;/*</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; Implement your own function</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; */</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;abstract public double f(double xValue);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public double leftHandSum (int numRect){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double sum = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double change = getChange (numRect);//Width of the rectangles</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double TempA = a;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; while (TempA &lt; b){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum += f(TempA) * change;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TempA += change;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return sum;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public double rightHandSum (int numRect){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double sum = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double change = getChange (numRect);//Width of the rectangles</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double TempA = a;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; while (TempA &lt; b){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TempA += change;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum += f(TempA) * change;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return sum;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public double getTrapezoidalSum (int numRect){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;double sum = 0 ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double change = getChange (numRect);//Width of the rectangles</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; while (a &lt; b){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sum += getTrapezoidArea(f(a),f(a+change),change);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a += change;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return sum;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double getTrapezoidArea (double f, double fP , double change){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return 0.5 * (f+fP) * change;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public double getEpsilon (double current, double previous){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return (100*(Math.abs(current-previous)))/current;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double getChange (int numRect){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return Math.abs(b-a) / numRect;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public void printEpsilonSmaller(){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int numOfRectangles = 1;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double previousSum, currentSum ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; previousSum = getMidpointSum(numOfRectangles); &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; while (true){//Infinite Loop</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numOfRectangles *= 2;</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currentSum = getMidpointSum(numOfRectangles);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(getEpsilon (currentSum,previousSum));</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; previousSum = currentSum;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; public double getMidpointSum(int numOfSquares) {</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double sum = 0;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double TempA = a;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double change = getChange(numOfSquares);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; TempA += change/2;//Goes the x value of the midpoint</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; while (TempA &lt; b) {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum += (f(TempA)*(change));</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TempA += change;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return sum;</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">class FunA extends Function {</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.99px; height: 98.99px;"><img alt="" src="images/image09.png" style="width: 292.99px; height: 98.99px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; //Limits of integration</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double a ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double b ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp;FunA(int a, int b){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;super (a, b);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;public double f(double xValue){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return 200 * (xValue / (xValue + 5)) * Math.pow(Math.E, -(2 * xValue / 30));</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp;}</span></p><p class="c1"><span class="c0">&nbsp;</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">class FunB extends Function {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; //Limits of integration</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double a ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double b ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 250.01px; height: 76.00px;"><img alt="" src="images/image08.png" style="width: 250.01px; height: 76.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp;FunB(int a, int b){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;super (a, b);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;public double f(double xValue){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;return 1-xValue-Math.pow(-4*xValue, 3)+Math.pow(2*xValue, 5);</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp;}</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">class FunC extends Function {</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 294.01px; height: 96.00px;"><img alt="" src="images/image11.png" style="width: 294.01px; height: 96.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; //Limits of integration</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double a ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; private double b ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp;FunC(int a, int b){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;super (a, b);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;public double f(double xValue){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;return Math.pow((xValue + (1/xValue)),2);</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp;}</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; </span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Analysis for epsilon</span></p><p class="c1"><span class="c0">The function &nbsp;printEpsilonSmaller() ena</span><span class="c0">bles us to prove the conjecture that &ldquo;Integrals that are calculated via Riemann sums get closer to a certain true value where the definite integral truly lies&rdquo;. In essence, the study of epsilon will allow us to determine how different are two different sums. </span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Because this specific implementation featured the number of rectangles, &nbsp;the number of rectangles had to be varied for the purposes of our studies. There is an inverse proportionality between the number of rectangles and the width of the rectangle. The greater one is , the lesser the other. If we want to increase the numbers of rectangles in order to decrease the width of each rectangle. </span></p><p class="c1"><img src="images/image01.png"></p><p class="c1"><span class="c0">The width of the rectangles were varied by multiplying the previous number of rectangles by 2 . </span></p><p class="c1"><span class="c0">So every value of the numOfRectangles variable is a power of 2. </span></p><p class="c1"><span class="c0">2,4,8,16,32&hellip;&hellip;&hellip;</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; public void printEpsilonSmaller(){</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; int numOfRectangles = 1;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; double previousSum, currentSum ;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; previousSum = getMidpointSum(numOfRectangles); &nbsp; </span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; while (true){//Infinite Loop</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numOfRectangles *= 2;</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currentSum = getMidpointSum(numOfRectangles);</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(getEpsilon (currentSum,previousSum));</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; previousSum = currentSum;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; }</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 159.98px; height: 148.00px;"><img alt="" src="images/image10.png" style="width: 159.98px; height: 148.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">&nbsp; &nbsp;</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">Since the scope is to study the function of the numOfRectangles on the value of the integral, a while loop was constructed to infinitely show the values of epsilon. This provides a large enough sample size for our study. </span></p><p class="c1"><span class="c0">The value of epsilon decrease and </span></p><p class="c1"><img src="images/image02.png"></p><p class="c1"><span class="c0">As the number of tests gets larger the value of epsilon will approach 0 as the number of calculation reaches an infinite value. </span></p><div><p class="c4 c1 c3"><span class="c5 c35"></span></p></div></body></html>